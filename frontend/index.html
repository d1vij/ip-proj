<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Divij Verma IP Project</title>

    <!-- FiraCode Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&amp;family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&amp;display=swap" rel="stylesheet">

    <!-- prism.css -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism.min.css">
    <!-- prism.min.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/prism.min.js" integrity="sha512-UOoJElONeUNzQbbKQbjldDf9MwOHqxNz49NNJJ1d90yp+X9edsHyJoAs6O4K19CZGaIdjI5ohK+O2y5lBTW6uQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <!-- prism-python.min.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/components/prism-python.min.js" integrity="sha512-3qtI9+9JXi658yli19POddU1RouYtkTEhTHo6X5ilOvMiDfNvo6GIS6k2Ukrsx8MyaKSXeVrnIWeyH8G5EOyIQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    
    <!-- prism-javascript-min.js -->
     <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/components/prism-javascript.min.js" integrity="sha512-yvw5BDA/GQu8umskpIOBhX2pDLrdOiriaK4kVxtD28QEGLV5rscmCfDjkrx52tIgzLgwzs1FsALV6eYDpGnEkQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<link rel="stylesheet" href="src/style.scss"></head>


<!-- custom stylesheet -->


<body>
    <main>
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
%pip install pandas matplotlib pymongo --no-cache-dir nbconvert
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                <hr class="custom">
                <div class="cell"><h1 class="header box-around">Hello</h1>
<p style="text-transform: capitalize;">Html test</p></div>
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
import os
import csv
import pymongo
import json
import sqlite3

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                   
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
CONNECTION_URL = "mongodb+srv://vermadivij:elections@cluster1.kicphp2.mongodb.net/?retryWrites=true&amp;w=majority&amp;appName=cluster1"
DATABASE_NAME = "votes"
CLASSES = [
    "10A",
    "10B",
    "10C",
    "10D",
    "10E",
    "10F",
    "10G",
    "10H",
    "10I",
    "10J",
    "11A",
    "11B",
    "11C",
    "11D",
    "11E",
    "12A",
    "12B",
    "12C",
    "12D",
    "9A",
    "9B",
    "9C",
    "9D",
    "9E",
    "9F",
    "9G",
    "9H",
    "9I",
    "9J",
    "absentees",
    "candidates",
]

_SPACE = " "
_UNDERSCORE = "_"
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
def replace_spaces(string: str, replace_with=_UNDERSCORE):
    return string.replace(_SPACE, replace_with)
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
def fetch_and_parse(collection_name: str) -&gt; dict:

    conn = pymongo.MongoClient(CONNECTION_URL)
    database = conn.get_database(DATABASE_NAME)

    RESULTS: dict[str, dict[str, int]] = {}

    collection = database.get_collection(collection_name)
    found_documents: list[dict] = list(collection.find({}))

    for doc in found_documents:
        vote_data: list[dict[str, str]] = doc["vote_data"]

        for vote_obj in vote_data:
            post = vote_obj["post"]
            voted_candidate = vote_obj["name"]

            # post doesnt exist
            if post not in RESULTS:
                RESULTS[post] = {}

            # post exists
            RESULTS[post][voted_candidate] = RESULTS[post].get(voted_candidate, 0) + 1

    return RESULTS


def save_to_csv(data: dict, path: str):
    # create path if it doesnt exists
    if not (os.path.exists(path)):
        open(path, "x").close()

    with open(path, "w+") as file:

        writer = csv.writer(file)
        writer.writerow(["Post", "Candidate", "Total Votes"])

        for postname, candidates in data.items():
            for name, votes in candidates.items():
                writer.writerow([postname, name, votes])
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
file_paths = [
    os.path.join(os.getcwd(), "class-wise", collection + ".csv")
    for collection in CLASSES
]

with open("candidate-data.json", "r") as file:
    # since all files would have the same posts and candidates
    # reading the columns from any of it would work
    candidate_data = json.loads(file.read())


def compile_single_class(file_path: str):
    with open(file_path, "r") as file:
        reader = csv.reader(file)

        # skipping column names row
        next(reader)

        candidates = {
            post: {name: 0 for name in names} for post, names in candidate_data.items()
        }
        for line in reader:
            post = line[0]
            name = line[1]
            votes = int(line[2])
            candidates[post][name] = votes

    return candidates


def compile_csvs_to_json():

    # empty dictionary to store the compiled vote data
    compiled_json = {
        post_name: {
            class_name: {name: 0 for name in candidate_data[post_name]}
            for class_name in CLASSES
        }
        for post_name in candidate_data.keys()
    }

    for curr_class in CLASSES:
        class_wise_votes = compile_single_class(
            os.path.join(os.getcwd(), "class-wise", curr_class + ".csv")
        )
        for post, candidates in class_wise_votes.items():
            for name, votes in candidates.items():
                compiled_json[post][curr_class][name] += votes

    return compiled_json


def create_dataframes():
    compiled = compile_csvs_to_json()
    dataframes = {}

    for post in compiled:
        post_dataframe = pd.DataFrame(
            compiled[post]
        ).T  # transpose cuz otherwise there would be 31 columns
        dataframes[post] = post_dataframe

    return dataframes
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
from sqlite3 import OperationalError
from typing import Union, Literal


# typings
REPR_UNION = Union[Literal["string"], Literal["list"], None]
QUERY_UNION = Union[None, list[tuple[str]], str, list[str]]


def query(
    query: str,
    *,
    is_updation=False,  # is the current query contains some kind of updation ?? Doesnt return anything if true
    return_repr: REPR_UNION = None,  # Returns output as string or list of lines if passed any of the value. Prints the result if None.
    return_rows=False,  # Return rows as lists of tuples ??
    table_heading: str | None = None,  # Title printed before printing output
) -&gt; QUERY_UNION:
    try:
        results = cursor.execute(query)
    except OperationalError as err:
        print(f"Error in querying -&gt; {query}")
        print("** Row / Column names with spaces should be enlcosed within quotes **")
        print(err)
        return

    if is_updation:
        return
    if return_rows:
        return results.fetchall()
    else:
        lines: list[str] = []
        # printing table header if provided
        if table_heading is not None:
            print(table_heading)

        # printing column names
        lines.append(" ".join(desc[0] for desc in results.description))

        # for most part left padding works fine
        label_lengths = [len(desc[0]) for desc in results.description]

        for row in results.fetchall():
            line = []
            for idx, col in enumerate(row):

                # left justifing current column value based on length fo current column's label
                line.append(str(col).ljust(label_lengths[idx] + 1))
            lines.append("".join(line))

        if return_repr == "string":
            return "\n".join(lines)
        elif return_repr == "list":
            return lines
        else:
            print(*lines, sep="\n")
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
# NOTE: converting json to csv to again json is redundant and indivisual collections could directly be compiled to final json
BASE_DIR = os.path.join(os.path.dirname(os.getcwd()), "ip-proj", "class-wise")

if not (os.path.exists("class-wise")):
    os.mkdir("class-wise")

for collection in CLASSES:

    # try to save that collection
    try:
        save_to_csv(
            fetch_and_parse(collection),
            os.path.join(BASE_DIR, collection + ".csv"),
        )
        print(f"Saved collection : {collection}")

    # gracefully handle any raised exception
    except Exception as e:
        print(f"Exception occured in saving {collection} document, Exception: {e}")
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
result_dataframes = create_dataframes()
print("Found Posts", *result_dataframes.keys(), sep="\n")
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
conn = sqlite3.connect(DATABASE_NAME + ".db")
cursor = conn.cursor()
for name, post_df in result_dataframes.items():
    name = name.replace(_SPACE, _UNDERSCORE)
    post_df.columns = [name.replace(_SPACE, _UNDERSCORE) for name in post_df.columns]
    post_df.to_sql(name, conn, if_exists="replace", index_label="Class")
    conn.commit()
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
# captian boy dataframe
cb = result_dataframes["Captain Boy"]
# captian girl dataframe
cg = result_dataframes["Captain Girl"]
# vice captian boy dataframe
vcb = result_dataframes["Vice Captain Boy"]
# vice captian girl dataframe
vcg = result_dataframes["Vice Captain Girl"]
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
# test printing rows

print(cb[cb.index.str.contains(r"9\w")])  # &lt;--- regex btw
print(cg[cg.index.str.contains(r"10\w")])
print(vcb[vcb.index.str.contains(r"11\w")])
print(vcg[vcg.index.str.contains(r"12\w")])
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
# classes where the candidate has 0 votes
for post_name, post_df in result_dataframes.items():
    print("\n", post_name, sep="")
    for name in post_df.columns:
        candidate_series = post_df[name]
        empty_vote_classes = candidate_series[candidate_series == 0].index

        print(
            f"{(name)} got zero votes in classes-&gt;",
            *empty_vote_classes,
        )
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
for post_name, post_df in result_dataframes.items():
    for name in post_df.columns:
        query(
            f"select class as {name} from {replace_spaces(post_name)} where {name} == 0"
        )
        print()
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
# classes where a candidate won majority of votes

for post_name, post_df in result_dataframes.items():
    print("\n", name, sep="")

    print(post_df.idxmax())
    print()
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
for post_name, post_df in result_dataframes.items():
    for name in post_df.columns:
        print(name)
        query(f"select max({name}) as 'Got Votes', class from {replace_spaces(post_name)}")

                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
# mean votes a candidate got across all classes

for post_name, post_df in result_dataframes.items():
    print(post_name)
    print(post_df.mean())
    query(
        f"""select {', '.join([f'round(avg({name}), 6) as {name}' for name in post_df.columns])}
                    from {replace_spaces(post_name)}
                """
    )
    print()
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
# median votes a candidate got across all classes

for post_name, post_df in result_dataframes.items():
    print(post_name)
    print(post_df.median())
    print()

# ---no sql equivalent for median---
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
# calculating modal votes would be irrelevant
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
# total votes across all classes
for post_name, post_df in result_dataframes.items():
    print(post_name)
    print(post_df.sum())
    print()
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
# equivalent sql query
for post_name, post_df in result_dataframes.items():
    query(
        f"""
        select {', '.join([f"sum({name}) as {name}" for name in post_df.columns])}
        from {replace_spaces(post_name)}
        """,
        table_heading="Total Votes"
    )
    print()
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
# candidate popularity trends - comparing candidate performances across classes

from matplotlib.ticker import MultipleLocator


def plot_popularity_trends(post_name: str, post_df: pd.DataFrame):

    # extracting rows belonging to a particular class from the post's dataframe using regular expressions
    class_wise_dataframes = [
        post_df[post_df.index.str.contains(_re)]
        for _re in [r"9\w", r"10\w", r"11\w", r"12\w"]  # &lt;--- again regex
    ]

    # dividing the plot into 4 subplots
    fig, axes = plt.subplots(2, 2, figsize=(15, 7))

    subplot_positions = [
        (0, 0),
        (0, 1),
        (1, 0),
        (1, 1),
    ]  # since there are only 4 classes / subplots
    linestyles = [":", "-", "--", "-.", "solid"]

    for idx in range(4):
        pos = subplot_positions[idx]
        class_df = class_wise_dataframes[idx]
        sections = class_df.index

        for idx, (candidate_name, candidate_series) in enumerate(class_df.items()):
            # plotting a subplot for each class
            axes[pos].plot(sections, candidate_series, label=candidate_name.replace(_UNDERSCORE, _SPACE), linestyle=linestyles[idx])  # type: ignore

        axes[pos].set_xlabel("class")
        axes[pos].set_ylabel("Votes")

        axes[pos].set_ylim(0, post_df.max().max() + 1)

        # values on y-axis would have a difference of 1
        axes[pos].yaxis.set_major_locator(MultipleLocator(1))

    fig.suptitle(post_name, fontsize=32)

    # setting a common legend for the whole plot
    handles, labels = axes[0, 0].get_legend_handles_labels()
    fig.legend(handles, labels, loc="upper right", ncols=2, fontsize=15)

    plt.show()


plot_popularity_trends("Captain Boy", cb)
plot_popularity_trends("Captain Girl", cg)
plot_popularity_trends("Vice Captain Boy", vcb)
plot_popularity_trends("Vice Captain Boy", vcg)
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
total_classes = len(cb.index)


fig, axes = plt.subplots(2, 2, figsize=(10, 7.5), constrained_layout=True)
fig.suptitle("Percent Classes Won by Candidates", fontsize=32)

subplot_positions = [
        (0, 0),
        (0, 1),
        (1, 0),
        (1, 1),
    ]

colors = plt.cm.copper_r(np.linspace(0,0.50,5)) # type: ignore


for idx, (post_name, post_df) in enumerate(result_dataframes.items()):
    pos = subplot_positions[idx]

    classes_won_by_candidate_series = post_df.idxmax(1)
    count_series = (classes_won_by_candidate_series
                        .groupby(classes_won_by_candidate_series)
                        .count()
                        .sort_values(ascending=False)
                        )
    percents_series = count_series / total_classes
    
    max_val = percents_series.max()

    axes[pos].set_title(post_name)
    axes[pos].pie(
        percents_series,
        labels=percents_series.index.map(
            lambda name: name.replace(_UNDERSCORE, _SPACE)
        ),
        autopct="%1.1f%%",
        startangle=180,
        colors=colors,
    )
    axes[pos].set(aspect='equal')



plt.show()
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
print(f"Runtime of {(time() - start_time):.2f} seconds")
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
                
                <div class="cell">
                <pre class="language-python">                <code class="language-python">
                
# converting this notebook to html document
import subprocess

subprocess.run(["npx", "tsc"], cwd="parser", capture_output=False)
subprocess.run(["node", "parser.js"], cwd="parser", capture_output=False)
                </code>
                </pre>
                <div class="output">


                </div>
                </div>
    </main>


</body></html>